Synchronization was important to include in this multi thread environment. Synchronization was added to the Server, MessageQueue, and Room objects. This allowed updates to the objects to remain safe and accessible even when multiple clients tried to concurrently access the same data in order to complete the request successfully. A critical section is a region of code in which mutual exclusion must be guaranteed meaning that there can be at most one thread access the shared data at a time. Semaphores and mutexes were used to provide synchronization in this code. Mutexes allow for protection of any shared data structure. In Server, the constructor and destructor are critical sections, so pthread_mutex_init and pthread_mutex_destroy are used to make sure that the mutex can be initialized and destroyed properly. Hanlde_client_requests is also a critical section since several threads are being created in this function. M_ssock specifically needs to be protected with synchronization since it reused for all of the threads. A Guard object is used here for synchronization that helps prevent data races. A Guard object is also used in find_or_create_room as the access of m_rooms is a critical section. This allows for multiple thread to access m_rooms safely and without data races since without the guard, it is possible that multiple thread may try to create the same room at the same time. In MessageQueue, both mutexes and semaphores are used for synchronization. Semaphores were also used because it was also important to manage access to a limited resource since therethere is a queue being accessed and semaphore will allow a thread to wait until the queue is not full for enqueueing and to wait until the queue is not empty for dequeueing. Here, pthread_mutex_init and sem_init are used in the constructor and pthread_mutex_destroy and sem_destroy are used in the destructor to allow for safe initialization and  deletion. Critical section here also include enqueue and dequeue. A guard object is used in enqueue and dequeue to allow each thread to access the m_members queue individually. sem_post is used in enqueue to notify any thread waiting for a message to be available and sem_timedwait is used in dequeue so that the program waits for a message to properly transmit. In Room, synchronization is also added to the constructor and destructor with pthread_mutex_init and pthread_mutex_destroy to ensure safe access with initializing and destroying Room objects. Critical sections here include add_member and remove_member and guard objects are used to protect the members set since there is concurrent access. Broadcast_message also includes guard object as there is a critical section with access to members that also utilizes enqueue which allows updates to enqueue to occur safely. This prevent data races as it prevents several threads from broadcasting at the same time. User_in_room also include guard object as this critical section also includes members and access to the room object. Synchronization hazards are prevented since guard is used, as the block scope ensure that lock is never released, which will prevent deadlocks. Deadlocks occur whenever there are limited resources and multiple threads are using the same ones and the blocking synchronization prevents threads from making progress, meaning that a deadlock could also occur at broadcast_message due to accessing the queue and in find_or_create room due to accessing the rooms, which is why the guards object and even more useful here. The critical sections are also not very long so that that it still performs efficiently. Critical sections also only access with their object boundaries so that they are synchronized only from methods of that object.
